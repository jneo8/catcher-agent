apiVersion: v1
kind: Pod
metadata:
  name: test-insufficient-cpu
  namespace: failure-cases
spec:
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
        - matchExpressions:
          - key: test-node
            operator: In
            values:
            - "true"
          - key: failure-node
            operator: NotIn
            values:
            - "true"
  containers:
  - name: app
    image: nginx:latest
    resources:
      requests:
        cpu: "1000"  # Request 1000 CPU cores (unrealistic) - SCENARIO A
        memory: "128Mi"
---
apiVersion: v1
kind: Pod
metadata:
  name: test-image-pull-failure
  namespace: failure-cases
spec:
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
        - matchExpressions:
          - key: test-node
            operator: In
            values:
            - "true"
          - key: failure-node
            operator: NotIn
            values:
            - "true"
  containers:
  - name: app
    image: nonexistent-registry.io/nonexistent-image:latest  # SCENARIO B
---
apiVersion: v1
kind: Pod
metadata:
  name: test-container-failure
  namespace: failure-cases
spec:
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
        - matchExpressions:
          - key: test-node
            operator: In
            values:
            - "true"
          - key: failure-node
            operator: NotIn
            values:
            - "true"
  restartPolicy: Never  # Pod will enter Failed phase when container exits with error
  containers:
  - name: app
    image: busybox:latest
    command: ["/bin/sh", "-c", "echo 'Application starting...'; sleep 5; echo 'Application crashed!'; exit 1"]
    # SCENARIO C: Container exits with error code, pod enters Failed phase
